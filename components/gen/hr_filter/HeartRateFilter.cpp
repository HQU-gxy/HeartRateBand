//
// File: HeartRateFilter.cpp
//
// MATLAB Coder version            : 23.2
// C/C++ source code generated on  : 01-Apr-2024 16:42:51
//

// Include Files
#include "HeartRateFilter.h"
#include "BiquadFilter.h"
#include "coder_array.h"
#include "hr_filter_types.h"
#include "hr_filter_types1.h"

// Function Declarations
namespace gen {
static void hr_filter_init(HeartRateFilter *aInstancePtr);

}

// Function Definitions
//
// Arguments    : void
// Return Type  : hr_filterStackData *
//
namespace gen {
hr_filterStackData *HeartRateFilter::getStackData()
{
  return &SD_;
}

//
// DOFILTER Filters input x and returns output y.
//
// Arguments    : HeartRateFilter *aInstancePtr
// Return Type  : void
//
static void hr_filter_init(HeartRateFilter *aInstancePtr)
{
  hr_filterStackData *localSD;
  localSD = aInstancePtr->getStackData();
  localSD->pd->Hd.cSFunObject.W0_FILT_STATES.set_size(8192);
  localSD->pd->Hd_not_empty = false;
}

//
// Arguments    : void
// Return Type  : void
//
HeartRateFilter::HeartRateFilter()
{
  SD_.pd = &pd_;
  hr_filter_init(this);
}

//
// Arguments    : void
// Return Type  : void
//
HeartRateFilter::~HeartRateFilter() = default;

//
// DOFILTER Filters input x and returns output y.
//
// Arguments    : const real32_T x_data[]
//                const int32_T x_size[2]
//                real32_T y_data[]
//                int32_T y_size[2]
// Return Type  : void
//
void HeartRateFilter::hr_filter(const real32_T x_data[],
                                const int32_T x_size[2], real32_T y_data[],
                                int32_T y_size[2])
{
  static const int8_T iv[6]{1, 0, -1, 1, 0, -1};
  dsp_BiquadFilter_0 *obj;
  int32_T i;
  //  MATLAB Code
  //  Generated by MATLAB(R) 23.2 and DSP System Toolbox 23.2.
  //  Generated on: 01-Apr-2024 14:56:08
  //  To generate C/C++ code from this function use the codegen command.
  //  Type 'help codegen' for more information.
  if (!static_cast<int32_T>(pd_.Hd_not_empty)) {
    //  The following code was used to design the filter coefficients:
    //
    //  Fstop1 = 0.4;   % First Stopband Frequency
    //  Fpass1 = 0.75;  % First Passband Frequency
    //  Fpass2 = 3.6;   % Second Passband Frequency
    //  Fstop2 = 10;    % Second Stopband Frequency
    //  Astop1 = 8;     % First Stopband Attenuation (dB)
    //  Apass  = 1;     % Passband Ripple (dB)
    //  Astop2 = 6;     % Second Stopband Attenuation (dB)
    //  Fs     = 100;   % Sampling Frequency
    //
    //  h = fdesign.bandpass('fst1,fp1,fp2,fst2,ast1,ap,ast2', Fstop1, Fpass1,
    //  ...
    //                      codckjldsfjaf Fpass2, Fstop2, Astop1, Apass, Astop2,
    //                      Fs);
    //
    //  Hd = design(h, 'butter', ...
    //      'MatchExactly', 'passband', ...
    //      'SystemObject', true,...
    //       UseLegacyBiquadFilter=true);
    pd_.Hd.isInitialized = 0;
    // System object Constructor function: dsp.BiquadFilter
    pd_.Hd.cSFunObject.P0_ICRTP = 0.0F;
    for (i = 0; i < 6; i++) {
      pd_.Hd.cSFunObject.P1_RTP1COEFF[i] = static_cast<real32_T>(iv[i]);
    }
    pd_.Hd.cSFunObject.P2_RTP2COEFF[0] = -1.95130742F;
    pd_.Hd.cSFunObject.P2_RTP2COEFF[1] = 0.952939689F;
    pd_.Hd.cSFunObject.P2_RTP2COEFF[2] = -1.67796791F;
    pd_.Hd.cSFunObject.P2_RTP2COEFF[3] = 0.73648566F;
    pd_.Hd.cSFunObject.P3_RTP3COEFF[0] = 0.115184478F;
    pd_.Hd.cSFunObject.P4_RTP_COEFF3_BOOL[0] = true;
    pd_.Hd.cSFunObject.P3_RTP3COEFF[1] = 0.115184478F;
    pd_.Hd.cSFunObject.P4_RTP_COEFF3_BOOL[1] = true;
    pd_.Hd.cSFunObject.P3_RTP3COEFF[2] = 0.0F;
    pd_.Hd.cSFunObject.P4_RTP_COEFF3_BOOL[2] = false;
    // System object Initialization function: dsp.BiquadFilter
    for (i = 0; i < 8192; i++) {
      pd_.Hd.cSFunObject.W0_FILT_STATES[i] = pd_.Hd.cSFunObject.P0_ICRTP;
    }
    pd_.Hd.cSFunObject.W1_PreviousNumChannels = -1;
    pd_.Hd_not_empty = true;
  }
  obj = &pd_.Hd.cSFunObject;
  // System object Outputs function: dsp.BiquadFilter
  y_size[0] = 1;
  y_size[1] = x_size[1];
  i = 0;
  if (pd_.Hd.cSFunObject.W1_PreviousNumChannels == -1) {
    pd_.Hd.cSFunObject.W1_PreviousNumChannels = x_size[1];
  }
  for (int32_T k{0}; k < x_size[1]; k++) {
    int32_T memOffset;
    real32_T denAccum;
    real32_T tmpState;
    memOffset = k << 2;
    denAccum = obj->P3_RTP3COEFF[0] * x_data[i];
    denAccum -= obj->P2_RTP2COEFF[0] * obj->W0_FILT_STATES[memOffset];
    tmpState =
        denAccum - obj->P2_RTP2COEFF[1] * obj->W0_FILT_STATES[memOffset + 1];
    denAccum = obj->P1_RTP1COEFF[0] * tmpState;
    denAccum += obj->P1_RTP1COEFF[1] * obj->W0_FILT_STATES[memOffset];
    denAccum += obj->P1_RTP1COEFF[2] * obj->W0_FILT_STATES[memOffset + 1];
    obj->W0_FILT_STATES[memOffset + 1] = obj->W0_FILT_STATES[memOffset];
    obj->W0_FILT_STATES[memOffset] = tmpState;
    denAccum *= obj->P3_RTP3COEFF[1];
    denAccum -= obj->P2_RTP2COEFF[2] * obj->W0_FILT_STATES[memOffset + 2];
    tmpState =
        denAccum - obj->P2_RTP2COEFF[3] * obj->W0_FILT_STATES[memOffset + 3];
    denAccum = obj->P1_RTP1COEFF[3] * tmpState;
    denAccum += obj->P1_RTP1COEFF[4] * obj->W0_FILT_STATES[memOffset + 2];
    y_data[i] =
        denAccum + obj->P1_RTP1COEFF[5] * obj->W0_FILT_STATES[memOffset + 3];
    obj->W0_FILT_STATES[memOffset + 3] = obj->W0_FILT_STATES[memOffset + 2];
    obj->W0_FILT_STATES[memOffset + 2] = tmpState;
    i++;
  }
}

} // namespace gen

//
// File trailer for HeartRateFilter.cpp
//
// [EOF]
//
